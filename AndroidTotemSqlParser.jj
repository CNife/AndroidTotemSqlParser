PARSER_BEGIN(AndroidTotemSqlParser)

package generated;

import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;
import ast.*;

public class AndroidTotemSqlParser {
    public static List<Statement> parse(InputStream input) throws Exception {
        AndroidTotemSqlParser parser = new AndroidTotemSqlParser(input);
        return parser.statements();
    }
}

PARSER_END(AndroidTotemSqlParser)

// 跳过空白字符
SKIP : { " " | "\t" | "\r" | "\n" }

// 关键字
TOKEN : {
      <AS: "AS">
    | <CLASS: "CLASS">
    | <CREATE: "CREATE">
    | <DELETE: "DELETE">
    | <DROP: "DROP">
    | <FROM: "FROM">
    | <INSERT: "INSERT">
    | <INTO: "INTO">
    | <SELECT: "SELECT">
    | <SELECTDEPUTY: "SELECTDEPUTY">
    | <SET: "SET">
    | <UPDATE: "UPDATE">
    | <VALUES: "VALUES">
    | <WHERE: "WHERE">
}

// 数据类型
TOKEN : {
      <INT: "INT">
    | <CHAR: "CHAR">
}

// 运算符
TOKEN : {
      <ARROW: "->">
    | <COMMA: ",">
    | <DOT: ".">
    | <EQUALS: "=">
    | <SEMICOLON: ";">
    | <LEFT_BRACKET: "(">
    | <RIGHT_BRACKET: ")">
    | <LESS_THAN: "<">
    | <GREATER_THAN: ">">
    | <LESS_THAN_OR_EQUALS: "<=">
    | <GREATER_THAN_OR_EQUALS: ">=">
    | <ADD: "+">
    | <MINUS: "-">
    | <MULTIPLY: "*">
    | <DIVIDE: "/">
}

// 标识符和数字
TOKEN : {
      <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <INTEGER_LITERAL: <LEADING_DIGIT> (<DIGIT>)*>
    | <#LETTER: ["A"-"Z", "a"-"z"]>
    | <#DIGIT: ["0"-"9"]>
    | <#LEADING_DIGIT: ["1"-"9"]>
}

List<Statement> statements():
{
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    ( s = statement() { statements.add(s); } )*
    <EOF>
    { return statements; }
}

Statement statement():
{
    Statement s;
}
{
    s = selectStatement()
    <SEMICOLON>
    { return s; }
}

SelectStatement selectStatement():
{
    List<Projection> projectionList;
    String className;
    WhereClause whereClause = null;
    Token token;
}
{
    <SELECT>
    projectionList = projectionList()
    <FROM>
    token = <IDENTIFIER> { className = token.image; }
    [
        <WHERE>
        whereClause = whereClause()
    ]
    { return new SelectStatement(projectionList, className, whereClause); }
}

List<Projection> projectionList():
{
    List<Projection> projectionList = new ArrayList<Projection>();
    Projection projection;
}
{
    projection = projection()
    { projectionList.add(projection); }
    (
        <COMMA>
        projection = projection()
        { projectionList.add(projection); }
    )*
    { return projectionList; }
}

Projection projection():
{
    Projection projection;
    Token token = null;
}
{
    (
      projection = binaryProjection()
    | projection = simpleOrCrossClassProjection()
    )
    [ <AS> token = <IDENTIFIER> ]
    {
        projection.name = token == null ? null : token.image;
        return projection;
    }
}

BinaryProjection binaryProjection():
{
    String left;
    Expression right;
    BinaryProjection.OperatorType operator;
    Token token;
}
{
    <LEFT_BRACKET>
    token = <IDENTIFIER> { left = token.image; }
    operator = operator()
    token = <INTEGER_LITERAL>
    <RIGHT_BRACKET>
    {
        right = new Expression(Integer.valueOf(token.image));
        return new BinaryProjection(left, right, operator);
    }
}

BinaryProjection.OperatorType operator():
{
    BinaryProjection.OperatorType operator;
}
{
     <ADD> { return BinaryProjection.OperatorType.ADD; }
   | <MINUS> { return BinaryProjection.OperatorType.MINUS; }
   | <MULTIPLY> { return BinaryProjection.OperatorType.MULTIPLY; }
   | <DIVIDE> { return BinaryProjection.OperatorType.DIVIDE; }
}

//noinspection Convert2Diamond
Projection simpleOrCrossClassProjection():
{
    List<String> classNames = new ArrayList<String>();
    Token token;
}
{
    LOOKAHEAD(2)
    (
        token = <IDENTIFIER> { classNames.add(token.image); }
        ( <ARROW> token = <IDENTIFIER> { classNames.add(token.image); } )+
        <DOT>
        token = <IDENTIFIER>
        { return new CrossClassProjection(classNames, token.image); }
    )
    | token = <IDENTIFIER> { return new SimpleProjection(token.image); }
}

WhereClause whereClause():
{
    String left;
    Expression right;
    WhereClause.BooleanOperatorType operator;
    Token token;
}
{
    token = <IDENTIFIER> { left = token.image; }
    operator = booleanOperator()
    token = <INTEGER_LITERAL>
    {
        right = new Expression(Integer.valueOf(token.image));
        return new WhereClause(left, right, operator);
    }
}

WhereClause.BooleanOperatorType booleanOperator():
{}
{
      <EQUALS> { return WhereClause.BooleanOperatorType.EQUALS; }
    | <LESS_THAN> { return WhereClause.BooleanOperatorType.LESS_THAN; }
    | <GREATER_THAN> { return WhereClause.BooleanOperatorType.GREATER_THAN; }
    | <LESS_THAN_OR_EQUALS> { return WhereClause.BooleanOperatorType.LESS_THAN_OR_EQUALS; }
    | <GREATER_THAN_OR_EQUALS> { return WhereClause.BooleanOperatorType.GREATER_THAN_OR_EQUALS; }
}