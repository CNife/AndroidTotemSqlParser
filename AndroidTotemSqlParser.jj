PARSER_BEGIN(AndroidTotemSqlParser)

package generated;

import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;
import ast.*;

public class AndroidTotemSqlParser {
    public static List<Statement> parse(InputStream input) throws Exception {
        AndroidTotemSqlParser parser = new AndroidTotemSqlParser(input);
        return parser.statements();
    }
}

PARSER_END(AndroidTotemSqlParser)

// 跳过空白字符
SKIP : { " " | "\t" | "\r" | "\n" }

// 关键字
TOKEN : {
      <AS: "AS">
    | <CLASS: "CLASS">
    | <CREATE: "CREATE">
    | <DELETE: "DELETE">
    | <DROP: "DROP">
    | <FROM: "FROM">
    | <INSERT: "INSERT">
    | <INTO: "INTO">
    | <SELECT: "SELECT">
    | <SELECTDEPUTY: "SELECTDEPUTY">
    | <SET: "SET">
    | <UPDATE: "UPDATE">
    | <VALUES: "VALUES">
    | <WHERE: "WHERE">
}

// 数据类型
TOKEN : {
      <TYPE: <INT> | <CHAR> >
    | <#INT: "INT">
    | <#CHAR: "CHAR">
}

// 运算符
TOKEN : {
      <ARROW: "->">
    | <COMMA: ",">
    | <DOT: ".">
    | <EQUALS: "=">
    | <SEMICOLON: ";">
    | <LEFT_BRACKET: "(">
    | <RIGHT_BRACKET: ")">
    | <LESS_THAN: "<">
    | <GREATER_THAN: ">">
    | <LESS_THAN_OR_EQUALS: "<=">
    | <GREATER_THAN_OR_EQUALS: ">=">
    | <ADD: "+">
    | <MINUS: "-">
    | <MULTIPLY: "*">
    | <DIVIDE: "/">
}

// 标识符和数字
TOKEN : {
      <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    | <INTEGER_LITERAL: <LEADING_DIGIT> (<DIGIT>)*>
    | <#LETTER: ["A"-"Z", "a"-"z"]>
    | <#DIGIT: ["0"-"9"]>
    | <#LEADING_DIGIT: ["1"-"9"]>
}

List<Statement> statements():
{
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    ( s = statement() { statements.add(s); } )*
    <EOF>
    { return statements; }
}

Statement statement():
{
    Statement s;
}
{
    (
        s = selectStatement()
      | s = createClassStatement()
    )
    <SEMICOLON>
    { return s; }
}

SelectStatement selectStatement():
{
    List<Projection> projectionList;
    String className;
    WhereClause whereClause = null;
}
{
    <SELECT>
    projectionList = projectionList()
    <FROM>
    className = identifier()
    [
        <WHERE>
        whereClause = whereClause()
    ]
    { return new SelectStatement(projectionList, className, whereClause); }
}

List<Projection> projectionList():
{
    List<Projection> projectionList = new ArrayList<Projection>();
    Projection projection;
}
{
    projection = projection()
    { projectionList.add(projection); }
    (
        <COMMA>
        projection = projection()
        { projectionList.add(projection); }
    )*
    { return projectionList; }
}

Projection projection():
{
    Projection projection;
    String name = null;
}
{
    (
      projection = binaryProjection()
    | projection = simpleOrCrossClassProjection()
    )
    [ <AS> name = identifier() ]
    {
        projection.name = name;
        return projection;
    }
}

BinaryProjection binaryProjection():
{
    String left;
    int right;
    BinaryProjection.OperatorType operator;
}
{
    <LEFT_BRACKET>
    left = identifier()
    operator = operator()
    right = integer()
    <RIGHT_BRACKET>
    { return new BinaryProjection(left, new Expression(right), operator); }
}

int integer():
{
    Token token;
}
{
    token = <INTEGER_LITERAL>
    { return Integer.valueOf(token.image); }
}

BinaryProjection.OperatorType operator():
{
    BinaryProjection.OperatorType operator;
}
{
     <ADD> { return BinaryProjection.OperatorType.ADD; }
   | <MINUS> { return BinaryProjection.OperatorType.MINUS; }
   | <MULTIPLY> { return BinaryProjection.OperatorType.MULTIPLY; }
   | <DIVIDE> { return BinaryProjection.OperatorType.DIVIDE; }
}

Projection simpleOrCrossClassProjection():
{
    List<String> classNames = new ArrayList<String>();
    String className;
    String propertyName;
}
{
    LOOKAHEAD(2)
    (
        className = identifier() { classNames.add(className); }
        ( <ARROW> className = identifier() { classNames.add(className); } )+
        <DOT>
        propertyName = identifier()
        { return new CrossClassProjection(classNames, propertyName); }
    )
    | token = <IDENTIFIER> { return new SimpleProjection(token.image); }
}

WhereClause whereClause():
{
    String left;
    int right;
    WhereClause.BooleanOperatorType operator;
}
{
    left = identifier()
    operator = booleanOperator()
    right = integer()
    { return new WhereClause(left, new Expression(right), operator); }
}

WhereClause.BooleanOperatorType booleanOperator():
{}
{
      <EQUALS> { return WhereClause.BooleanOperatorType.EQUALS; }
    | <LESS_THAN> { return WhereClause.BooleanOperatorType.LESS_THAN; }
    | <GREATER_THAN> { return WhereClause.BooleanOperatorType.GREATER_THAN; }
    | <LESS_THAN_OR_EQUALS> { return WhereClause.BooleanOperatorType.LESS_THAN_OR_EQUALS; }
    | <GREATER_THAN_OR_EQUALS> { return WhereClause.BooleanOperatorType.GREATER_THAN_OR_EQUALS; }
}

String identifier():
{
    Token token;
}
{
    token = <IDENTIFIER>
    { return token.image; }
}

CreateClassStatement createClassStatement():
{
    String className;
    List<Property> propertyList;
}
{
    <CREATE> <CLASS>
    className = identifier()
    propertyList = propertyList()
    { return new CreateClassStatement(className, propertyList); }
}

List<Property> propertyList():
{
    List<Property> propertyList = new ArrayList<Property>();
    Property property;
}
{
    <LEFT_BRACKET>
    property = property()
    { propertyList.add(property); }
    (
        <COMMA>
        property = property()
        { propertyList.add(property); }
    )*
    <RIGHT_BRACKET>
    { return propertyList; }
}

Property property():
{
    String name;
    PropertyType type;
}
{
    name = identifier()
    type = propertyType()
    { return new Property(name, type); }
}

PropertyType propertyType():
{
    Token token;
}
{
    token = <TYPE>
    { return PropertyType.typeOf(token.image); }
}